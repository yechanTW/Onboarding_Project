# **GraphQL**

### [공식 문서](https://graphql.org/)

페이스북에서 만든 쿼리 언어로  , API를 만들 때 사용하고 동시에 쿼리에 대한 데이터를 받을 수 있는 런타임이기도 합니다. 기존에 REST api가 가지던 UnderFetching, OverFetching 2가지의 문제를 해결할 수 있는 좋은 방안입니다.

## **OverFetching 과 UnderFetching**

### **OverFetcing**

REST api 를 사용하게 되면 URI에 할당된 데이터를 가져오기 때문에 필요한 정보 이외에도 더 많은 정보를 fetching하는 경우가 생깁니다. 예를 들어 , 내 정보 중에서 이메일만 필요하지만 , 이메일 / 이름 / 전화 번호 등등 을 모두 가져온 이후 그 중 이메일만 뽑는 경우가 생깁니다. 이처럼 필요한 정보 이외에 불필요하게 더 많은 정보를 가져오는 경우가 생깁니다. 이 경우를 OverFetching이라고 하며 , GraphQL은 자신이 원하는 정보만 쿼리문으로 정확하게 가져올 수 있어서 이 overFetching문제를 해결할 수 있습니다.

### **UnderFetcing**

반대로 n개의 다른 데이터가 필요한데 , 이 데이터들이 각각 다른 URI에 있는 경우 , 최악의 경우에는 한 URI당 한 개의 데이터만 가져올 수 있는 경우가 생깁니다. 그렇게 되면 엄청나게 많은 데이터 통신이 필요합니다. GraphQL은 쿼리로 여러 데이터를 묶어서 한번에 fetching이 가능합니다.


REST api에서 여러번 fetching 또는 불필요한 정보들을 가져오는 문제를 GraphQL은 쿼리문을 통해 효과적으로 해결할 수 있습니다.

## **구조**

### **Query**
쿼리는 객체에 대한 특정 필드를 요청하는 것을 말합니다. CRUD에서 Read 역할을 맡습니다.

```graphQL
query {
    post {
        title
    }
}
```
라는 요청을 보내게 되면

```graphQL
{
  "data" : {
    "post" : {
      "title" : "hello !"
    }
  }
}
```
라는 결과가 오게 됩니다. 상당히 직관적이고 알기 쉽습니다.

</br>

### **Mutation**
쿼리가 서버에 데이터를 요청하는 용도라면 , mutation은 서버 측 데이터를 수정하기 위해 사용됩니다. CRUD에서 Read를 제외한 Create , Update, Delete 역할을 수행합니다.


### **Introspection**
기존 서버-클라이언트 협업시 API 명세서를 주고받는 절차가 반드시 필요했습니다. 하지만 이 API 명세서가 관리가 제대로 되지 않아서 문제가 발생하곤 했습니다. 이런 문제를 해결하는 것이 인트로스펙션 기능입니다. 서버 자체에서 현재 서버에 정의된 스키마의 실시간 정보공유를 통해서 클라이언트 사이드에서 따로 API 명세서를 요청할 필요가 없어졌습니다. 클라이언트 사이드에서 실시간으로 현재 서버에서 정의하고 있는 스키마를 받아들이고 , 그에 맞게 쿼리문을 작성하기만 하면 됩니다.

### [Yalco GraphQL 강의 실습](https://github.com/yechanTW/GraphQL)
