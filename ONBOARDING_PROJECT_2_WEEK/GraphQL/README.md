# GraphQL

### [공식 문서](https://graphql.org/)

## 왜 사용하는가 ?

### 기존 REST api 통신의 한계

</br>

**1. overfetching**

특정 URI에서 내가 필요한 정보 외에도 더 많은 정보가 들어있어서 불필요하게 많은 정보를 가져오는 경우가 생깁니다.

</br>

**2. underfetching**

반대로 , 서로 다른 n개의 데이터가 필요한데 이 데이터들이 각각 다른 URI에 있는 경우 , 최악의 경우 1개 URI당 1개의 데이터만 있는 경우 많은 통신이 필요합니다.

</br>

**3. API 유지보수의 어려움**

한번 만들어진 API URI는 수정하고 , 변경하기 힘든 단점이 있었습니다.

</br>

즉 , 관리해야하는 Endpoint* 가 많아지기 때문에 생기는 문제점이라고 할 수 있는데, GraphQL은 Endpoint를 하나로 만들어서 , 이 문제들을 해결했습니다. (찾아보니 , Github도 graphQL을 사용하고 있다고 합니다.) 한 개의 Endpoint를 가지므로 요청을 보내는 곳이 한 곳이고 , 그 외의 APi는 신경 쓸 필요가 없어서 유지보수가 쉬워집니다. 또한 원하는 데이터를 단 한번의 요청으로 가져올 수 있어서 기존 REST api가 가지던 overfetching이나 underfetching 문제가 발생하지 않습니다.

</br>

## 단점 ?

이렇게 좋은거라면 , REST api가 다 바뀌어야 하지 않나 생각했었는데 , 생각보다 여러 단점을 보유하고 있었습니다. 

</br>

**1. 캐싱**
REST api 는 특정 URL을 기준으로 쉽게 캐싱*을 할 수 있지만 , GraphQL은 한 가지의 Endpoint로 요청을 보내서 캐싱이 복잡합니다. 하지만 apollo client를 사용함으로써 캐싱 문제를 해결할 수 있습니다.

</br>

**2. 파일 전송**
기존 REST api에서는 파일을 전송할 때 , ContentType을 multipart/form-data로 설정해서 전송하지만 , GraphQL의 쿼리는 Json형식을 따르기 때문에 항상 application/json 의 요청을 보내게 됩니다. 그래서 파일 전송에 어려움이 있는데 , 이때 미들웨어를 사용해서 구현해야 합니다.(Apollo Link 등). 

</br>

**3. 고정된 요청 / 응답**

요청의 횟수를 줄이고 , 응답의 크기를 줄이는 것이 graphQL의 장점인데 , 오히려 고정되어있는 요청 및 응답의 경우에서는 Query로 인해 요청의 크기가 더 커지는 경우가 발생합니다.

</br>

## 어떤 경우에 사용하는 것이 좋은가 ?

### GraphQL

* 다양한 요청에 응답할 수 있어야 할 때 
* 대부분의 요청이 CRUD에 해당할 때

</br>

### REST api

* 캐싱을 잘 사용하고 싶을 때
* 파일 전송 등의 경우
* 요청의 변동이 거의 없는 경우

</br>

Endpoint : api가 서버에서 리소스에 접근할 수 있도록 하는 URL\
캐싱 : 자주 접근하는 데이터를 캐시 메모리 영역으로 가져와서 접근하는 것.